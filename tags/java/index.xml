<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Selenium</title><link>https://www.selenium.dev/tags/java/</link><description>Recent content in Java on Selenium</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 13 Dec 2023 10:37:28 +0000</lastBuildDate><atom:link href="https://www.selenium.dev/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Removal of AbstractEventListener + EventFiringWebDriver + WebDriverEventListener</title><link>https://www.selenium.dev/blog/2023/java-removal-of-deprecated-events-classes/</link><pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2023/java-removal-of-deprecated-events-classes/</guid><description>Upgrading to WebDriverListener and EventFiringDecorator Decorating the webdriver
new EventFiringWebDriver(driver); // Old approach new EventFiringDecorator().decorate(driver); // New approach Implementing method wrappers One may find the need to have their own custom implementations be used for underlying decorated method calls. An example may be wanting to use your own findElement implementation to store metadata from web elements. One can go down a deep rabbit hole of decorators ( extending WebDriverDecorator and such ), so to keep things simple we will extend EventFiringDecorator since we want a single decorator to handle all our listener events.</description></item><item><title>Java 8 support in Selenium</title><link>https://www.selenium.dev/blog/2023/java-8-support/</link><pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2023/java-8-support/</guid><description>“If it ain’t broke, don’t fix it” is a saying you may have heard, but sometimes it’s necessary to move on from our old favorites. That’s why we’re announcing that Selenium will stop supporting Java 8 on September 30, 2023. This applies for both the Java bindings and the Selenium Grid.
Selenium has long supported Java 8, but as technology evolves, so must we. One of the primary reasons for this change is that Java 8 reached the end of active support over a year ago.</description></item><item><title>InvalidSelectorException has changed</title><link>https://www.selenium.dev/blog/2023/invalid-selector-exception-has-changed/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2023/invalid-selector-exception-has-changed/</guid><description>Before Selenium 4.8.2 in Java and C#, when an invalid locator was used to identify an element, the resulting behavior would be inconsistent in our bindings.
For example, let&amp;rsquo;s check the following code:
ArrayList&amp;lt;Class&amp;lt;? extends Exception&amp;gt;&amp;gt; expectedExceptions = new ArrayList&amp;lt;&amp;gt;(); expectedExceptions.add(org.openqa.selenium.NoSuchElementException.class); expectedExceptions.add(org.openqa.selenium.StaleElementReferenceException.class); expectedExceptions.add(org.openqa.selenium.ElementNotInteractableException.class); expectedExceptions.add(org.openqa.selenium.InvalidElementStateException.class); return new FluentWait&amp;lt;&amp;gt;(driver) .withTimeout(Duration.ofMillis(ELEMENT_IDENTIFICATION_TIMEOUT)) .pollingEvery(Duration.ofMillis(ELEMENT_IDENTIFICATION_POLLING_DELAY)) .ignoreAll(expectedExceptions) .until(nestedDriver -&amp;gt; { nestedDriver.findElement(By.xpath(&amp;#34;invalid-xpath&amp;#34;)).click; }); The expected result before this change would be that the driver waits until the timeout expires and then throw an InvalidSelectorException.</description></item><item><title>BELLATRIX Test Automation Framework for C# and JAVA</title><link>https://www.selenium.dev/blog/2022/bellatrix-test-automation-framework/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2022/bellatrix-test-automation-framework/</guid><description>Over the last decade, a large ecosystem of Open Source projects has sprouted up around Selenium. Selenium is often used for automating web applications for testing purposes, but it does not include a testing framework. Nowadays, Selenium Ecosystem initiatives try to give popularity to popular open-source test automation frameworks maintained by people outside of the core Selenium maintainers. One of these frameworks is BELLATRIX, invented by Anton Angelov. It has two versions - C# and Java.</description></item><item><title>Removing Legacy Protocol Support</title><link>https://www.selenium.dev/blog/2022/legacy-protocol-support/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2022/legacy-protocol-support/</guid><description>The Selenium team prides itself on how seriously it takes backwards compatibility. A lot of care has gone into the Java bindings, especially, to ensure very few breaking changes over the years. There is Selenium code written 15 years ago that can still run with Selenium 4 libraries! Providing this exceptional amount of support comes with a large maintenance burden, though, and we need to be able to properly meet the needs of the vast majority of our userbase.</description></item></channel></rss>