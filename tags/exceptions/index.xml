<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exceptions on Selenium</title><link>https://www.selenium.dev/tags/exceptions/</link><description>Recent content in Exceptions on Selenium</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 24 Apr 2023 08:49:56 +0200</lastBuildDate><atom:link href="https://www.selenium.dev/tags/exceptions/index.xml" rel="self" type="application/rss+xml"/><item><title>InvalidSelectorException has changed</title><link>https://www.selenium.dev/blog/2023/invalid-selector-exception-has-changed/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2023/invalid-selector-exception-has-changed/</guid><description>Before Selenium 4.8.2 in Java and C#, when an invalid locator was used to identify an element, the resulting behavior would be inconsistent in our bindings.
For example, let&amp;rsquo;s check the following code:
ArrayList&amp;lt;Class&amp;lt;? extends Exception&amp;gt;&amp;gt; expectedExceptions = new ArrayList&amp;lt;&amp;gt;(); expectedExceptions.add(org.openqa.selenium.NoSuchElementException.class); expectedExceptions.add(org.openqa.selenium.StaleElementReferenceException.class); expectedExceptions.add(org.openqa.selenium.ElementNotInteractableException.class); expectedExceptions.add(org.openqa.selenium.InvalidElementStateException.class); return new FluentWait&amp;lt;&amp;gt;(driver) .withTimeout(Duration.ofMillis(ELEMENT_IDENTIFICATION_TIMEOUT)) .pollingEvery(Duration.ofMillis(ELEMENT_IDENTIFICATION_POLLING_DELAY)) .ignoreAll(expectedExceptions) .until(nestedDriver -&amp;gt; { nestedDriver.findElement(By.xpath(&amp;#34;invalid-xpath&amp;#34;)).click; }); The expected result before this change would be that the driver waits until the timeout expires and then throw an InvalidSelectorException.</description></item></channel></rss>