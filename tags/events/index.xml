<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Events on Selenium</title><link>https://www.selenium.dev/tags/events/</link><description>Recent content in Events on Selenium</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 08 Dec 2023 17:36:12 -0600</lastBuildDate><atom:link href="https://www.selenium.dev/tags/events/index.xml" rel="self" type="application/rss+xml"/><item><title>Removal of AbstractEventListener + EventFiringWebDriver + WebDriverEventListener</title><link>https://www.selenium.dev/blog/2023/java-removal-of-deprecated-events-classes/</link><pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/blog/2023/java-removal-of-deprecated-events-classes/</guid><description>Upgrading to WebDriverListener and EventFiringDecorator Decorating the webdriver
new EventFiringWebDriver(driver); // Old approach new EventFiringDecorator().decorate(driver); // New approach Implementing method wrappers One may find the need to have their own custom implementations be used for underlying decorated method calls. An example may be wanting to use your own findElement implementation to store metadata from web elements. One can go down a deep rabbit hole of decorators ( extending WebDriverDecorator and such ), so to keep things simple we will extend EventFiringDecorator since we want a single decorator to handle all our listener events.</description></item></channel></rss>